#lang racket
;; 1.11
;; Because in the last line, the recursion caused by subst is on sexp and sexp is a smaller substructure.

;; 1.12
(module exercise1-12 racket
  (provide subst)
  (define (subst new old slist)
    (if (null? slist)
	'()
	(cons
	 (let ((sexp (car slist)))
	   (if (symbol? sexp)
	       (if (eqv? sexp old) new sexp)
	       (subst new old sexp)))
	 (subst new old (cdr slist))))))

;; 1.13
;; the original grammar is
;; S-list ::= ({S-exp}*))
;; S-exp  ::= Symbol | S-list
(module exercise1-13 racket
  (provide subst)
  (define (subst new old slist)
    (map
     (lambda (sexp)
       (if (symbol? sexp)
	   (if (eqv? sexp old) new sexp)
	   (subst new old sexp)))
     slist)))

(require (rename-in 'exercise1-12 (subst subst1-12)))
(require (rename-in 'exercise1-13 (subst subst1-13)))

(let ((slist '(+ a b (+ b b) (+ c d))))
  (subst1-12 'd 'b slist)
  (subst1-13 'd 'b slist))
